{
    "sourceFile": "src/main/java/com/vincent/inc/Saturday/util/ReflectionUtils.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1689363915761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1689363915761,
            "name": "Commit-0",
            "content": "package com.vincent.inc.Saturday.util;\r\n\r\nimport java.lang.annotation.Annotation;\r\nimport java.lang.reflect.Field;\r\nimport java.util.Arrays;\r\n\r\nimport org.springframework.data.domain.Example;\r\nimport org.springframework.data.domain.ExampleMatcher;\r\nimport org.springframework.data.domain.ExampleMatcher.GenericPropertyMatcher;\r\nimport org.springframework.util.ObjectUtils;\r\n\r\nimport com.google.gson.Gson;\r\n\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic final class ReflectionUtils \r\n{\r\n    public static final String CASE_SENSITIVE = \"CASE_SENSITIVE\";\r\n    public static final String CONTAINS = \"CONTAINS\";\r\n    public static final String ENDS_WITH = \"ENDS_WITH\";\r\n    public static final String EXACT = \"EXACT\";\r\n    public static final String IGNORE_CASE = \"IGNORE_CASE\";\r\n    public static final String REGEX = \"REGEX\";\r\n    public static final String START_WITH = \"START_WITH\";\r\n    public static final Gson gson = new Gson();\r\n\r\n    /**\r\n     * this method will replace all field value of original to target only if target field value is not null\r\n     * if origin and target are not the same class then return false\r\n     * @param original original object will be replace with tartget\r\n     * @param target \r\n     * @return true if replace is success else false\r\n     */\r\n    public static boolean replaceValue(Object original, Object target)\r\n    {\r\n        try\r\n        {\r\n            if(original.getClass() != target.getClass())\r\n                return false;\r\n\r\n            Field[] originalFields = original.getClass().getDeclaredFields();\r\n            Field[] targetFields = target.getClass().getDeclaredFields();\r\n            \r\n            for (int i = 0; i < originalFields.length; i++) \r\n            {\r\n                originalFields[i].setAccessible(true);\r\n                targetFields[i].setAccessible(true);\r\n\r\n                // Object originalValue = originalFields[i].get(original);\r\n                Object targetValue = targetFields[i].get(target);\r\n                \r\n                if(validAnnotation(targetFields[i].getAnnotations()))\r\n                    originalFields[i].set(original, targetValue);\r\n\r\n                originalFields[i].setAccessible(false);\r\n                targetFields[i].setAccessible(false);\r\n            }\r\n\r\n            return true;\r\n        }\r\n        catch(Exception ex)\r\n        {\r\n            log.error(ex.getMessage(), ex);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * this method will patch all field value of original to target only if target field value is not null\r\n     * if origin and target are not the same class then return false\r\n     * @param original original object will be patch with target\r\n     * @param target \r\n     * @return true if patch is success else false\r\n     */\r\n    public static boolean patchValue(Object original, Object target)\r\n    {\r\n        try\r\n        {\r\n            if(original.getClass() != target.getClass())\r\n                return false;\r\n\r\n            Field[] originalFields = original.getClass().getDeclaredFields();\r\n            Field[] targetFields = target.getClass().getDeclaredFields();\r\n            \r\n            for (int i = 0; i < originalFields.length; i++) \r\n            {\r\n                originalFields[i].setAccessible(true);\r\n                targetFields[i].setAccessible(true);\r\n\r\n                // Object originalValue = originalFields[i].get(original);\r\n                Object targetValue = targetFields[i].get(target);\r\n\r\n                if(targetValue != null && validAnnotation(targetFields[i].getAnnotations()))\r\n                    originalFields[i].set(original, targetValue);\r\n\r\n                originalFields[i].setAccessible(false);\r\n                targetFields[i].setAccessible(false);\r\n            }\r\n\r\n            return true;\r\n        }\r\n        catch(Exception ex)\r\n        {\r\n            log.error(ex.getMessage(), ex);\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    private static boolean validAnnotation(Annotation[] annotations)\r\n    {\r\n        for (Annotation annotation : annotations) \r\n        {\r\n            if(annotation.annotationType() == jakarta.persistence.Id.class)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private static boolean containIdAnnotation(Annotation[] annotations) {\r\n        var match = Arrays.stream(annotations).parallel().anyMatch(e -> {\r\n            return e.annotationType() == jakarta.persistence.Id.class;\r\n        });\r\n\r\n        return match;\r\n    }\r\n\r\n    public static boolean isEqual(Object object1, Object object2)\r\n    {\r\n        return ReflectionUtils.gson.toJson(object1).equals(ReflectionUtils.gson.toJson(object2));\r\n    }\r\n\r\n    public static <T extends Object> Example<T> getMatchAllMatcher(T object)\r\n    {\r\n        return getMatchAllMatcher(object, IGNORE_CASE);\r\n    }\r\n\r\n    public static <T extends Object> Example<T> getMatchAnyMatcher(T object)\r\n    {\r\n        return getMatchAnyMatcher(object, IGNORE_CASE);\r\n    }\r\n\r\n    public static <T extends Object> Example<T> getMatchAllMatcher(T object, String matchCase)\r\n    {\r\n        try\r\n        {\r\n            ExampleMatcher customExampleMatcher = ExampleMatcher.matchingAll();\r\n\r\n            Field[] fields = object.getClass().getDeclaredFields();\r\n\r\n            for (Field field : fields) \r\n            {\r\n                field.setAccessible(true);\r\n                String fieldName = field.getName();\r\n                Object fieldValue = field.get(object);\r\n\r\n                if(fieldValue != null)\r\n                    customExampleMatcher.withMatcher(fieldName, getCase(matchCase));\r\n\r\n                field.setAccessible(false);\r\n            }\r\n\r\n            return Example.of(object, customExampleMatcher);\r\n        }\r\n        catch(Exception ex)\r\n        {\r\n            log.error(ex.getMessage(), ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public static <T extends Object> Example<T> getMatchAnyMatcher(T object, String matchCase)\r\n    {\r\n        try\r\n        {\r\n            ExampleMatcher customExampleMatcher = ExampleMatcher.matchingAny();\r\n\r\n            Field[] fields = object.getClass().getDeclaredFields();\r\n\r\n            for (Field field : fields) \r\n            {\r\n                field.setAccessible(true);\r\n                String fieldName = field.getName();\r\n                Object fieldValue = field.get(object);\r\n\r\n                if(fieldValue != null)\r\n                    customExampleMatcher.withMatcher(fieldName, getCase(matchCase));\r\n\r\n                field.setAccessible(false);\r\n            }\r\n\r\n            return Example.of(object, customExampleMatcher);\r\n        }\r\n        catch(Exception ex)\r\n        {\r\n            log.error(ex.getMessage(), ex);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private static GenericPropertyMatcher getCase(String matchCase) {\r\n        matchCase = matchCase.toUpperCase();\r\n\r\n        switch(matchCase) {\r\n            case \"CASE_SENSITIVE\":\r\n            case \"CASESENSITIVE\":\r\n                return ExampleMatcher.GenericPropertyMatchers.caseSensitive();\r\n            case \"CONTAINS\":\r\n            case \"CONTAIN\":\r\n                return ExampleMatcher.GenericPropertyMatchers.contains();\r\n            case \"ENDS_WITH\":\r\n            case \"END_WITH\":\r\n            case \"ENDSWITH\":\r\n            case \"ENDWITH\":\r\n                return ExampleMatcher.GenericPropertyMatchers.endsWith();\r\n            case \"EXACT\":\r\n            case \"EXACTS\":\r\n                return ExampleMatcher.GenericPropertyMatchers.exact();\r\n            case \"IGNORE_CASE\":\r\n            case \"IGNORE_CASES\":\r\n            case \"IGNORECASE\":\r\n            case \"IGNORECASES\":\r\n                return ExampleMatcher.GenericPropertyMatchers.ignoreCase();\r\n            case \"REGEX\":\r\n            case \"REGEXS\":\r\n                return ExampleMatcher.GenericPropertyMatchers.regex();\r\n                case \"START_WITH\":\r\n                case \"STARTS_WITH\":\r\n                case \"STARTSWITH\":\r\n                case \"STARTWITH\":\r\n                return ExampleMatcher.GenericPropertyMatchers.startsWith();\r\n            default:\r\n                return ExampleMatcher.GenericPropertyMatchers.storeDefaultMatching();\r\n        }\r\n    }\r\n\r\n    public static Object getIdFieldValue(Object object) {\r\n        try {\r\n            Field[] fields = object.getClass().getDeclaredFields();\r\n\r\n            for (int i = 0; i < fields.length; i++) \r\n            {\r\n                fields[i].setAccessible(true);\r\n                Object value = fields[i].get(object);\r\n    \r\n                if(!ObjectUtils.isEmpty(value) && containIdAnnotation(fields[i].getAnnotations())) {\r\n                    fields[i].setAccessible(false);\r\n                    return value;\r\n                }\r\n    \r\n                fields[i].setAccessible(false);\r\n            }\r\n\r\n            return null;\r\n        }\r\n        catch(Exception ex) {\r\n            log.error(ex.getMessage(), ex);\r\n            return null;\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}